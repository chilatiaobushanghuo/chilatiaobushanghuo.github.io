
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title> - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="数据结构代码整理线性表线性表的表示和实现线性表的顺序存储表示123456#define MAXSIZE 100typedef struct&amp;#123;    ElemType *elem;//存储空,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle"></h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title"></h1>
        <div class="stuff">
            <span>二月 02, 2021</span>
            

        </div>
        <div class="content markdown">
            <h1 id="数据结构代码整理"><a href="#数据结构代码整理" class="headerlink" title="数据结构代码整理"></a>数据结构代码整理</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的表示和实现"><a href="#线性表的表示和实现" class="headerlink" title="线性表的表示和实现"></a>线性表的表示和实现</h3><h4 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *elem;<span class="comment">//存储空间的基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的结构类型为SqList</span></span><br></pre></td></tr></table></figure>
<h4 id="顺序表中基本操作的实现"><a href="#顺序表中基本操作的实现" class="headerlink" title="顺序表中基本操作的实现"></a>顺序表中基本操作的实现</h4><ol>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造一个空的顺序表L</span></span><br><span class="line">    L.elem=<span class="keyword">new</span> ElemType[MAXSIZE];<span class="comment">//为顺序表分配一个大小为MAXSIZE的数组空间</span></span><br><span class="line">    <span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储空间分配失败退出</span></span><br><span class="line">    L.length=<span class="number">0</span>;<span class="comment">//空表长度为0</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;<span class="comment">//判断i值是否合理，不合理返回error</span></span><br><span class="line">    e=L.elem[i<span class="number">-1</span>];<span class="comment">//elem[i-1]存储第i个值</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表中查找值为e的数据元素，返回其序号</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.elem[i]==e) <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//查找成功，返回序号i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查找失败，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length+<span class="number">1</span>)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L.length==MAXSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">     L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">    L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=L.length<span class="number">-1</span>;j++)</span><br><span class="line">     L.elem[j<span class="number">-1</span>]=L.elem[j];</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线行表的的链式表示和实现"><a href="#线行表的的链式表示和实现" class="headerlink" title="线行表的的链式表示和实现"></a>线行表的的链式表示和实现</h3></li>
<li><p>定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ELemType data;<span class="comment">//结点的数据域</span></span><br><span class="line">    Struct LNode *next;<span class="comment">//结点的指针域</span></span><br><span class="line">&#125;LNode,*LinkList;<span class="comment">//LinkList为指向结构体LNode的指针类型</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造一个空的单链表L</span></span><br><span class="line">    L=<span class="keyword">new</span> LNode;<span class="comment">//生成新节点作为头节点，用头指针L指向头结点</span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//头指针的指针域置空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单链表的取值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在带头节点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值</span></span><br><span class="line">    p=L-&gt;next;j=l;<span class="comment">//初始化，P指向首元结点，计数器j初值赋为1</span></span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单链表的按值查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在带头结点的单链表L中查找值为e的元素</span></span><br><span class="line">    p=L-&gt;next;<span class="comment">//初始化，p指向首元结点</span></span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;p-&gt;data!=e)<span class="comment">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span></span><br><span class="line">    p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单链表的插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在带头结点的单链表L中第i个位置插入值为e的新结点</span></span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;(j&lt;i<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    S=<span class="keyword">new</span> LNode;</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;<span class="comment">//将结点*p的指针指向域结点*s</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单链表的删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在带头结点的单链表L中，删除第i个元素</span></span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next)&amp;&amp;(j&lt;i<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||(j&gt;i<span class="number">-1</span>)) <span class="keyword">return</span> ERROR;<span class="comment">//当i&gt;n或i&lt;1时，删除位置不合理</span></span><br><span class="line">    q=p-&gt;next;<span class="comment">//临时保存被删结点的位置以备释放</span></span><br><span class="line">    p-&gt;next=q-&gt;next;<span class="comment">//改变删除结点前驱结点的指针域</span></span><br><span class="line">    <span class="keyword">delete</span> q;<span class="comment">//释放删除结点的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前插法创建单链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatList_H</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//逆位序输入n个元素的值，建立带表头结点的单链表L</span></span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//先建立一个带头结点的空链表</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="keyword">new</span> LNode;<span class="comment">//生成新结点*p</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p-&gt;data;<span class="comment">//输入元素值赋给新结点*p的数据域</span></span><br><span class="line">        p-&gt;next=L-&gt;next;<span class="comment">//将新结点*p插入到头结点之后</span></span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后插法建立单链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//正序位输入n个元素的值，建立带表头结点的单链表L</span></span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//先建立一个带头结点的空链表</span></span><br><span class="line">    r=L;<span class="comment">//尾指针r指向头结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="keyword">new</span> LNode;<span class="comment">//生成新结点*p</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p-&gt;data;<span class="comment">//输入元素赋值给新结点的数据域</span></span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;r-&gt;next=p;<span class="comment">//将新节点*p插入到尾结点*r之后</span></span><br><span class="line">        r=p;<span class="comment">//r指向新的尾结点*p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3></li>
<li><p>双向链表的存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span><span class="comment">//指向直接前驱</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span><span class="comment">//指向直接后继</span></span><br><span class="line">&#125;DulNode,*DuLinkList;</span><br></pre></td></tr></table></figure></li>
<li><p>双向链表的插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在带头结点的双向链表L中第i个位置之前插入元素e</span></span><br><span class="line">    <span class="keyword">if</span>(!(p=GetElem_DuL(L,i)))<span class="comment">//在L中确定第i个元素的位置指针p</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//p为NULL 时，第i个元素不存在</span></span><br><span class="line">    s=<span class="keyword">new</span> DuLNode;<span class="comment">//生成新结点*s</span></span><br><span class="line">    s-&gt;data=e;<span class="comment">//将结点*e数据域置为e</span></span><br><span class="line">    s-&gt;prior-&gt;next=s;<span class="comment">//将结点*e插入L中</span></span><br><span class="line">    s-&gt;next=p;</span><br><span class="line">    p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双向链表的删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function">Status <span class="title">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除带头结点的双向链表L的第i个元素</span></span><br><span class="line">       <span class="keyword">if</span>(!(p=GetElem_DuL(L,i)))<span class="comment">//p为NULL时，第i个元素不存在</span></span><br><span class="line">        retrurn ERROR;</span><br><span class="line">       p-&gt;prior-&gt;next=p-&gt;next;<span class="comment">//修改被删除结点的前驱结点的后继指针</span></span><br><span class="line">    p-&gt;next-&gt;prior=p-&gt;prior;<span class="comment">//修改被删除结点的后继结点的前驱指针</span></span><br><span class="line">       <span class="keyword">delete</span> p;<span class="comment">//释放被删除结点的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="线行表的应用"><a href="#线行表的应用" class="headerlink" title="线行表的应用"></a>线行表的应用</h3></li>
<li><p>线行表的合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List &amp;LA,List LB)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将所有在线行表LB中但不在LA中的数据元素插入到LA中</span></span><br><span class="line">    m=ListLength(LA);n=ListLength(LB);<span class="comment">//求线行表的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(LB,i,e);<span class="comment">//取LB中第i个数据元素赋给e</span></span><br><span class="line">        <span class="keyword">if</span>(!LocateElem(LA,e))<span class="comment">//LA中不存在和e相同的数据元素</span></span><br><span class="line">            ListInsert(LA,++m,e);<span class="comment">//将e插在LA的最后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>有序表的合并</p>
<ol>
<li><p>顺序有序表的合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList LA,SqList LB,SqList &amp;LC)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//已知顺序有序表LA和LB的元素按值非递减排列</span></span><br><span class="line"> <span class="comment">//归并LA和LB得到新的顺序有序表LC，LC的元素也按值非递减排列</span></span><br><span class="line">    LC.length=LA.length+LB.length;<span class="comment">//新表长度为待合并两表的长度之和</span></span><br><span class="line">    LC.elem=<span class="keyword">new</span> ElemType[LC.length];<span class="comment">//为合并后的新表分配一个数组空间</span></span><br><span class="line">    pc=LC.elem;<span class="comment">//指针pc指向新表的第一个</span></span><br><span class="line">    pa=LA.elem;pb=LB.elem;<span class="comment">//指针pa和pb指向两个表的第一个元素</span></span><br><span class="line">    pa_last=LA.elem+LA.length<span class="number">-1</span>;<span class="comment">//指针pa_last指向LA的最后一个元素</span></span><br><span class="line">    pb_last=LB.elem+LB.length<span class="number">-1</span>;<span class="comment">//指针pa_last指向LB的最后一个元素</span></span><br><span class="line">    <span class="keyword">while</span>((pa&lt;=pa_last)&amp;&amp;(pb&lt;=pb_last))<span class="comment">//LA和LB均未到达表尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa&lt;=*pb) *pc++=*pa++;<span class="comment">//依次“摘取”两表中值较小的结点插入到LC的最后</span></span><br><span class="line">        <span class="keyword">else</span> *pc++=*pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pa&lt;=pa_last) *pc++=*pa++;<span class="comment">//LB已达到表尾，依次将LA的剩余元素插入到LC的最后</span></span><br><span class="line">    <span class="keyword">while</span>(pb&lt;=pb_last) *pc++=*pb++;<span class="comment">//LA已到达表尾，依次将LB的剩余元素插入到LC的最后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链式有序表的合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;LA,LinkList &amp;LB,linkList &amp;LC)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//已知单链表LA和LB的元素按值非递减排列</span></span><br><span class="line">    pa=LA-&gt;next;pb=LB-&gt;next;<span class="comment">//pa和pb的初值分别指向两个表的第一个结点</span></span><br><span class="line">    LC=LA;<span class="comment">//用LA的头结点作为LC的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa&amp;&amp;pb)</span><br><span class="line">    &#123;<span class="comment">//LA和LB均未到达表尾，依次“摘取”两表中值较小的结点插入到LC的最后</span></span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)<span class="comment">//“摘取”pa所值结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pa;<span class="comment">//将pa所指结点链接到pc所指结点之后</span></span><br><span class="line">            pc=pa;<span class="comment">//pc指向pa</span></span><br><span class="line">            pa=pa-&gt;next;<span class="comment">//pa指向下一结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//摘取pb所指结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pb;<span class="comment">//将pb所指结点链接到pc所指结点之后</span></span><br><span class="line">            pc=pb;<span class="comment">//pc指向pb</span></span><br><span class="line">            pb=pb-&gt;next;<span class="comment">//pb指向下一结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next=pa?pa:pb;<span class="comment">//将非空表的剩余段插入到pc所指结点之后</span></span><br><span class="line">    <span class="keyword">delete</span> LB;<span class="comment">//释放LB的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈的表示和操作的实现"><a href="#栈的表示和操作的实现" class="headerlink" title="栈的表示和操作的实现"></a>栈的表示和操作的实现</h3><ol>
<li><p>栈的存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;<span class="comment">//栈第指针</span></span><br><span class="line">    SElemType  *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;<span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造出一个空栈</span></span><br><span class="line">   S.base=<span class="keyword">new</span> SElemType[MAXSIZE];<span class="comment">//为顺序栈动态分配一个容量最大为MAXSIZE的数组空间</span></span><br><span class="line">   <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">    S.top=S.base;<span class="comment">//top初始为base，空栈</span></span><br><span class="line">    S.stacksize=MAXSIZE;<span class="comment">//stacksize置为最大容量MAZSIZE</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>入栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base==S.stacksize) <span class="keyword">return</span> ERROR;<span class="comment">//栈满</span></span><br><span class="line">    *S.top++=e;<span class="comment">//元素e压入栈顶，栈顶指针加1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除S的栈顶元素，并返回其值</span></span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base) <span class="keyword">return</span> ERROR;<span class="comment">//栈空</span></span><br><span class="line">    e=*--S.top;<span class="comment">//栈指针减1，将栈顶元素赋给e</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>取栈元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">zGetTop</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=S.base)<span class="comment">//栈非空</span></span><br><span class="line">        <span class="keyword">return</span> *(S.top<span class="number">-1</span>);<span class="comment">//返回栈顶元素的值，栈指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h3></li>
<li><p>链栈的存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造一个空栈</span></span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>入栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在栈顶插入元素e</span></span><br><span class="line">    p=<span class="keyword">new</span> StackNode;<span class="comment">//生成新结点</span></span><br><span class="line">    p-&gt;data=e;<span class="comment">//将新结点数据域置为e</span></span><br><span class="line">    p-&gt;next=S;<span class="comment">//将新结点插入栈顶</span></span><br><span class="line">    S=p;<span class="comment">//修改栈顶指针为p</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROE;<span class="comment">//栈空</span></span><br><span class="line">    e=S-&gt;data;<span class="comment">//将栈顶元素赋值给e</span></span><br><span class="line">    S=S-&gt;next;<span class="comment">//修改栈顶指针</span></span><br><span class="line">    <span class="keyword">delete</span> p;<span class="comment">//释放原栈顶的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>取栈顶元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回栈顶元素，不修改栈顶指针</span></span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;<span class="comment">//栈非空</span></span><br><span class="line">    <span class="keyword">return</span> S-&gt;data;<span class="comment">//返回栈顶元素，栈顶指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3></li>
<li><p>遍历输出链表中各个结点的递归算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void TraverseList(LinkList p)</span><br><span class="line">&#123;</span><br><span class="line">    if(p&#x3D;&#x3D;NULL) return;&#x2F;&#x2F;递归终止</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;endl;&#x2F;&#x2F;输出当前结点的数据域</span><br><span class="line">        TraverseList(p-&gt;next);&#x2F;&#x2F;p指向后继结点继续递归</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>经典Hanoi塔问题的递归算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hanoi</span><span class="params">(<span class="keyword">int</span> n,cahr A,<span class="keyword">char</span> B,<span class="keyword">char</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将塔座A上的n个圆盘按规则搬到C上，B做辅助塔</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) move(A,<span class="number">1</span>,C);<span class="comment">//将编号为1的圆盘从A移动到C</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Hanoi(n<span class="number">-1</span>,A,C,B);<span class="comment">//将A上编号为1到n-1的圆盘移到B，C做辅助塔</span></span><br><span class="line">        Move(A,n,C);<span class="comment">//将编号为n的圆盘从A移动到C</span></span><br><span class="line">        Hanoi(n<span class="number">-1</span>,B,A,C);<span class="comment">//将B上编号为1至n-1的圆盘移到C，A做辅助塔</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h3></li>
<li><p>队列的顺序存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;<span class="comment">//存储空间的基地址</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造一个空队列Q</span></span><br><span class="line">    Q.base=<span class="keyword">new</span> QElemType[MAXQSIZE];<span class="comment">//为队列分配一个最大容量为MAXSIZE的数组空间</span></span><br><span class="line">    <span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储空间分配失败</span></span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;<span class="comment">//头指针和尾指针置为零，队列为空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求队列长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回元素的个数，即队列的长度</span></span><br><span class="line">    <span class="keyword">return</span>(Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//插入元素e为Q的新的队尾元素</span></span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXQSIZE==Q.front)<span class="comment">//尾指针在循环意义上加1后等于头指针，表面队满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;ra</span><br><span class="line">    Q.base[Q.rear]=e;<span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//队尾指针加1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqUeue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除Q的队头元素，用e返回其值</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">    e=Q.base[Q.front];<span class="comment">//保存队头元素</span></span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MAXQSIZE;<span class="comment">//队头指针加1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>取循环队列的队头元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetHead</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回Q的队头元素，不修改队头指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front!Q.rear)<span class="comment">//队列非空</span></span><br><span class="line">        <span class="keyword">return</span> Q.base(Q.front);<span class="comment">//返回队头元素的值，队头指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链队的链式表示和实现"><a href="#链队的链式表示和实现" class="headerlink" title="链队的链式表示和实现"></a>链队的链式表示和实现</h3></li>
<li><p>存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造一个空队列</span></span><br><span class="line">    Q.front=Q.rear=<span class="keyword">new</span> QNode;<span class="comment">//生成新结点作为头结点，队尾和队头指针指向该结点</span></span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;<span class="comment">//头结点的指针置空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//插入元素e为Q的新的队尾元素</span></span><br><span class="line">    p=<span class="keyword">new</span> QNode;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;<span class="comment">//将新结点插入到队尾</span></span><br><span class="line">    Q.rear=p;<span class="comment">//修改队尾指针</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p) Q.rear=Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>取队首元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetHead</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回Q的队头元素，不修改指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear!=Q.front)</span><br><span class="line">        <span class="keyword">return</span> Q.front-&gt;next-&gt;dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h2></li>
</ol>
<h3 id="串的定义、存储结构及其运算"><a href="#串的定义、存储结构及其运算" class="headerlink" title="串的定义、存储结构及其运算"></a>串的定义、存储结构及其运算</h3><ol>
<li><p>串的顺序存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXSIZE+<span class="number">1</span>];<span class="comment">//存储串的一维数组</span></span><br><span class="line">    <span class="keyword">int</span> length；<span class="comment">//串当前的长度</span></span><br><span class="line">&#125;SString；</span><br></pre></td></tr></table></figure></li>
<li><p>串的链式存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80<span class="comment">//可有用户定义的大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Chunk *head,*tail;<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure></li>
<li><p>BF算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(SString S,SString T,<span class="keyword">int</span> poss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i=poss;j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;++i;++j&#125;<span class="comment">//继续比较后续字符</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;j=<span class="number">1</span>;<span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i-T.length;<span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>KMP算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S,SString T,<span class="keyword">int</span> poss)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//利用模式串T的next函数求T在主串中第pos个字符之后的位置</span></span><br><span class="line">    i=poss;j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||S.ch[i]==T.ch[j]) &#123;++i;++j&#125;</span><br><span class="line">        <span class="keyword">else</span> j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i-T.length;<span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>计算next值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T,<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求模式串T的next函数值并存入数组next</span></span><br><span class="line">    i=<span class="number">1</span>;next[<span class="number">1</span>]=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[i]==T.ch[j])</span><br><span class="line">        &#123;++i;++j;next[i]=j;&#125;</span><br><span class="line">        <span class="keyword">else</span> j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><ol>
<li><p>存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>ATOM,LIST&#125; ElemTag;<span class="comment">//ATOM==0: 原子；LIST==1: 子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag;<span class="comment">//公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        AtomType atom;<span class="comment">//atom是原子结点的值域，AtomType由用户定义</span></span><br><span class="line">        structpt&#123;<span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span>*<span class="title">hp</span>,*<span class="title">tp</span>;</span>&#125;ptr;<span class="comment">//ptr是表结点的指针域，ptr.hp和ptr.tp分别指向表头和表尾</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;*GList;<span class="comment">//广义表类型</span></span><br></pre></td></tr></table></figure>
<h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2></li>
</ol>
<h3 id="二叉树的性质和存储结构"><a href="#二叉树的性质和存储结构" class="headerlink" title="二叉树的性质和存储结构"></a>二叉树的性质和存储结构</h3><ol>
<li><p>二叉树的顺序存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100<span class="comment">//二叉树的最大结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSIZE];<span class="comment">//0号单页存储结点</span></span><br><span class="line">SqBiTree bt</span><br></pre></td></tr></table></figure></li>
<li><p>二叉树的二叉链式表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//结点数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<h3 id="遍历二叉树和线索二叉树"><a href="#遍历二叉树和线索二叉树" class="headerlink" title="遍历二叉树和线索二叉树"></a>遍历二叉树和线索二叉树</h3></li>
<li><p>中序遍历的递归算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);<span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;<span class="comment">//访问根节点</span></span><br><span class="line">        INOrderTraverse(T-&gt;rchild);<span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历的非递归算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStack(S);p=T;</span><br><span class="line">    q=<span class="keyword">new</span> BiTNode;</span><br><span class="line">    <span class="keyword">while</span>(p||!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(S,p);<span class="comment">//根指针进栈</span></span><br><span class="line">            p=p-&gt;lchild;<span class="comment">//根指针进栈，遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Pop(S,q);<span class="comment">//退栈</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;q-&gt;data;<span class="comment">//访问根节点</span></span><br><span class="line">            p=q-&gt;rchild;<span class="comment">//遍历右子树</span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>先序遍历的顺序建立二叉链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;<span class="comment">//递归结束，键空树</span></span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>) T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;<span class="comment">//生成根结点</span></span><br><span class="line">        T-&gt;data=ch;<span class="comment">//根结点数据域置为ch</span></span><br><span class="line">        CreateBiTree(T-&gt;lchild);<span class="comment">//递归创建左子树</span></span><br><span class="line">        CreateBitree(T-&gt;rchild);<span class="comment">//递归创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>复制二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T,BiTree &amp;NewT)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//复制一棵和T完全相同的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NeWT=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NewT=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild,NewT-&gt;lchild);<span class="comment">//递归复制左子树</span></span><br><span class="line">        Copy(T-&gt;rchild,NewT-&gt;rchild);<span class="comment">//递归复制右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>计算二叉树的深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//计算二叉树的T的深度</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=Depth(T-&gt;lchild);</span><br><span class="line">        n=Depth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span>(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>(n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>统计二叉树中结点的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//统计二叉树T中结点的个数</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果是空树，则结点个数为0，递归结束</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="number">1</span>;<span class="comment">//否则结点个数为左子树结点个数+右子树结点个数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线索二叉树的存储结构表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   TElemType data;<span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="keyword">int</span> LTag,RTag;<span class="comment">//左右标志</span></span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure></li>
<li><p>以结点p为根的子树中序线索化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">     InThreading(p-&gt;lchild);</span><br><span class="line">     <span class="keyword">if</span>(!p-&gt;lchild)</span><br><span class="line">     &#123;</span><br><span class="line">         p-&gt;LTag=<span class="number">1</span>;</span><br><span class="line">         p-&gt;lchild=pre;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> p-&gt;LTag=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(!pre-&gt;rchild)</span><br><span class="line">     &#123;</span><br><span class="line">         pre-&gt;RTag=<span class="number">1</span>;</span><br><span class="line">         pre-&gt;rchild=p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> pre-&gt;RTag=<span class="number">0</span>;</span><br><span class="line">     pre=p;<span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">     InTreading(p-&gt;rchild);<span class="comment">//右子树递归线索化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>带头结点的二叉树中序线索化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt,BiThrTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//中序遍历二叉树T，并将其中序线索化，Thrt指向头结点</span></span><br><span class="line">    Thrt=<span class="keyword">new</span> BiThrNode;<span class="comment">//建立头结点</span></span><br><span class="line">    Thrt-&gt;LTag=<span class="number">0</span>;<span class="comment">//头结点有左孩子，若树非空，则其左孩子为树根</span></span><br><span class="line">    Thrt-&gt;RTag=<span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;rchild=Thrt;</span><br><span class="line">    <span class="keyword">if</span>(!T) Thrt-&gt;lchild=Thrt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thrt-&gt;lchild=T;pre=Thrt;</span><br><span class="line">        inThreading(T);</span><br><span class="line">        pre-&gt;rchild=Thrt;</span><br><span class="line">        pre-&gt;RTag=<span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rchild=pre;<span class="comment">//头结点的右线索</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历二叉线索二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=T-&gt;lchild;<span class="comment">//p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;LTag==<span class="number">0</span>) p=p-&gt;lchild;<span class="comment">//沿左孩子向下</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//访问其左子树为空的结点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;RTag==<span class="number">1</span>&amp;&amp;p-&gt;rchild!=T)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;rchild;<span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以结点p为根的子树中序线索化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreeding(p-&gt;lchild);<span class="comment">//左子树递归线索化</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//p的左孩子为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag=<span class="number">1</span>;<span class="comment">//给p加上左线索</span></span><br><span class="line">            p-&gt;lchild=pre;<span class="comment">//p的左孩子指针指向pre</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;LTag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;rchild)<span class="comment">//pre的右孩子为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag=<span class="number">1</span>;<span class="comment">//给pre加上右线索</span></span><br><span class="line">            pre-&gt;rchild=p;<span class="comment">//pre的右孩子指针指向p(后继)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> pre-&gt;RTag=<span class="number">0</span>;</span><br><span class="line">        pre=p;<span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">        InThreading(p-&gt;rchild);<span class="comment">//右子树递归线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>带头结点的二叉树中序线索化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderThreading</span><span class="params">(BiThree &amp;Thrt,BiThree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//中序遍历二叉树T，并将其中序线索化，Thrt指向头结点</span></span><br><span class="line">    Thrt=<span class="keyword">new</span> BiThrNode;</span><br><span class="line">    Thrt-&gt;LTag=<span class="number">0</span>;</span><br><span class="line">    Thrt-&gt;RTag=<span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;rchild=Thrt;</span><br><span class="line">    <span class="keyword">if</span>(!T) Thrt-&gt;lchild=Thrt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thrt-&gt;lchild=T;pre=Thrt;</span><br><span class="line">        InThreading(T);</span><br><span class="line">        pre-&gt;rchild=Thrt;</span><br><span class="line">        pre-&gt;RTag=<span class="number">1</span>;</span><br><span class="line">        Thrt-&gt;rchild=pre;<span class="comment">//头结点的右线索指向pre</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历中序线索二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=T-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(p!=T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;LTag==<span class="number">0</span>) p=p-&gt;lchild;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;RTag==<span class="number">1</span>&amp;&amp;p-&gt;rchild!=T)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;rchild;<span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;rchild;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>哈夫曼树极其应用</p>
<ol>
<li><p>创建哈夫曼树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(HuffmanTree &amp;HT,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//构造哈夫曼树HT</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    HT=<span class="keyword">new</span> HTNode[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;HT[i].parent=<span class="number">0</span>;HT[i].lchild=<span class="number">0</span>;HT[i].rchild=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;HT[i].weight;</span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Select(HT,i<span class="number">-1</span>,s1,s2);</span><br><span class="line">        HT[s1].parent=i;HT[s2].parent=i;</span><br><span class="line">        HT[i].lchild=s1;HT[i].rchild=s2;</span><br><span class="line">        HT[i].weight=HT[s1].weight+HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据哈夫曼树求哈夫曼编码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHuffmanCode</span><span class="params">(HuffmanTree HT,HuffmanCode &amp;HC,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HC=<span class="keyword">new</span> <span class="keyword">char</span>*[n+<span class="number">1</span>];</span><br><span class="line">    cd=<span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        start=n<span class="number">-1</span>;</span><br><span class="line">        c=i;f=HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span>(f!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --start;</span><br><span class="line">            <span class="keyword">if</span>(HT[f].lchild==c) cd[start]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cd[start]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            c=f;f=HT[f].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        HC[i]=<span class="keyword">new</span> <span class="keyword">char</span>[n-start];</span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i],&amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2></li>
</ol>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><ol>
<li><p>图的邻接矩阵存储表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VerTexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VerTexType vex[MVNum];</span><br><span class="line">    ArcType arcs[MVNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure>
</li>
<li><p>采用邻接矩阵法表示创建无向网</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i;)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.vexs[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line">            G.arcs[i][j]=MaxInt;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G,arcnum;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;</span><br><span class="line">        i=LocateVex(G,v1);j=LocateVex(G,v2);</span><br><span class="line">        G.arcs[i][j]=w;</span><br><span class="line">        G.arcs[j][i]=G.arcs[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>图的邻接表存储表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//该边结点指向顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span><span class="comment">//指向下一条变得指针</span></span><br><span class="line">    OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>//顶点信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    verTexType data;</span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//邻接表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//图的当前顶点和边数</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure></li>
<li><p>采用邻接表表示法创建无向图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateUDC</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//采用邻接表表示法</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum;<span class="comment">//输入总顶点数和总边数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)<span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;<span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;++k)<span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">        i=LocateVex(G,v1);j=LocateVex(G,v2);</span><br><span class="line">        p1=<span class="keyword">new</span> ArcNode;<span class="comment">//生成一个新的边结点*p1</span></span><br><span class="line">        p1-&gt;adjvex=j;<span class="comment">//邻接点序号为j</span></span><br><span class="line">        p1-&gt;nextarc=G.vertices[i].firstarc;G.vertices[i].firstarc=p1;</span><br><span class="line">        <span class="comment">//将新结点*p1插入顶点v_i的边表头部</span></span><br><span class="line">        p2=<span class="keyword">new</span> ArcNode;</span><br><span class="line">        p2-&gt;adjvex=i;</span><br><span class="line">        p2-&gt;nextarc=G.vertices[j].firstarc;G.vertices[j].firstarc=p2;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>有向图的十字链存储表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tailvex,headvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> *<span class="title">hlink</span>,*<span class="title">tlink</span>;</span></span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125;ArcBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcBox *firstin,*firstout;</span><br><span class="line">&#125;VexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexNode xlist[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;OLGraph;</span><br></pre></td></tr></table></figure></li>
<li><p>邻接多重表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- - - - -无向图的邻接多重表存储表示- - - - -</span></span><br></pre></td></tr></table></figure>

<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3></li>
</ol>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ol>
<li><p>深度优先搜索遍历连通图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MVNum];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v;visited[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=FirstAdjVex(G,V);w&gt;=<span class="number">0</span>;w=NextAdjVex(G,v,m))</span><br><span class="line">        <span class="comment">//依次检查v的所有邻接点w，FirstAdjVex(G,v)表示v的第一个邻接点</span></span><br><span class="line">        <span class="comment">//NextAdjVex(G,v,w)表示v相对于w的下一个邻接点，w&gt;=表示存在邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) DFS(G,w);<span class="comment">//对v的尚未访问的邻接顶点w递归调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>采用邻接矩阵表示图的深度优先搜索遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AM</span><span class="params">(AMGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v;visted[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">        <span class="keyword">if</span>((G.vexnum;w++)</span><br><span class="line">           <span class="keyword">if</span>((G.arcs[v][m]!=<span class="number">0</span>)&amp;&amp;(!visited[w])) DFS_AM(G,w)；</span><br><span class="line">           <span class="comment">//G.arcs[v][w]!=0表示w是v的邻接点，如果w未访问，则递归调用DFS_AM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>采用邻接表表示图的深度优先搜索遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AL</span> <span class="params">(ALGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//图G为邻接表类型，从第v个顶点出发深度优先搜索遍历图G</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v;visited[v]=<span class="literal">true</span>;<span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true</span></span><br><span class="line">    p=G.vertices[v].firstarc;<span class="comment">//p指向v的边链表的第一个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//边结点非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        w=p-&gt;adjvex;<span class="comment">//表示w是v的邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) DFS_AL(G,w);<span class="comment">//如果w未访问，则递归调用</span></span><br><span class="line">        p=p-&gt;nextarc;<span class="comment">//p指向下一个边结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图的广度优先搜索"><a href="#图的广度优先搜索" class="headerlink" title="图的广度优先搜索"></a>图的广度优先搜索</h3></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v;visited[v]=<span class="literal">true</span>;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    EnQueue(Q,v);</span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(Q,u);</span><br><span class="line">        <span class="keyword">for</span>(w=FirstAdjVex(G,u);w&gt;=<span class="number">0</span>;w=NextAdjVex(G,u,w))</span><br><span class="line">            <span class="comment">//依次检查u的所有邻接点w，FirstAdjVex(G,u)表示u的第一个邻接点</span></span><br><span class="line">            <span class="comment">//nextAdjVex(G,u,w)表示u相对于w的下一个邻接点，w&gt;=0表示存在邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visted[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;w;visited[w]=<span class="literal">true</span>;<span class="comment">//访问w，并置访问标志数组相应分量值未true</span></span><br><span class="line">                EnQueue(Q,w);<span class="comment">//w进队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ol>
<li><p>prim算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(AMGraph G,verTexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//无向图G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T,输出T的各条边</span></span><br><span class="line">    k=LocateVex(G,u);<span class="comment">//k为顶点u的下标</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)<span class="comment">//对V-U的每一个顶点v_1,初始化closedge[j]</span></span><br><span class="line">        <span class="keyword">if</span>(j!=k) closedge[j]=&#123;u,G.arcs[k][j]&#125;;<span class="comment">//&#123;adjvex,lowcost&#125;</span></span><br><span class="line">    closedge[k].lowcost=<span class="number">0</span>;<span class="comment">//初始，U=&#123;u&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;++i)</span><br><span class="line">    &#123;<span class="comment">//选择其余n-1个顶点，生成n-1条边(n=G.vexnum)</span></span><br><span class="line">        u0=closedge[k].adjvex;<span class="comment">//u_0为最小边的一个顶点</span></span><br><span class="line">        v0=G.vexs[k];<span class="comment">//v_0为最小边的另一个顶点</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;u0&lt;&lt;v0;<span class="comment">//输出当前的最小边（u0，v0）</span></span><br><span class="line">        closedge[k].lowcost=<span class="number">0</span>;<span class="comment">//第k个顶点并入U集</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[k][j]&lt;closedge[j].lowcost)<span class="comment">//新顶点并入U后重新选择最小边</span></span><br><span class="line">                closedge[j]=&#123;G.vexs[k],G.arcs[k][j]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>克鲁斯卡尔算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> MiniSpanTree_ <span class="title">Krukal</span><span class="params">(AMGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//无向图G以邻接矩阵形式存储，构造G的最小生成树T，输出T的各条边</span></span><br><span class="line">    Sort(Edge);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        Vexset[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.arcnum;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v1=LocateVex(G,Edge[i].Head);</span><br><span class="line">        v2=LocateVex(G,Edge[i].Tail);</span><br><span class="line">        vs1=Vexset[v1];</span><br><span class="line">        vs2=Vexset[v2];</span><br><span class="line">        <span class="keyword">if</span>(vs1!=vs2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;Edge[i].Head&lt;&lt;Edge[i].Tail;<span class="comment">//输出此边</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line">                <span class="keyword">if</span>(Vexset[j]==vs2) Vexset[j]=vs1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h4></li>
<li><p>迪杰斯特拉算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(AMGraph G,<span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//用迪杰斯特拉算法求有向网G的v0顶点到其余顶点的最短路径</span></span><br><span class="line">    n=G.vexnum;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;n;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        S[v]=<span class="literal">false</span>;</span><br><span class="line">        D[v]=G.arcs[v0][v];</span><br><span class="line">        <span class="keyword">if</span>(D[v]&lt;MaxInt) Path[v]=v0;</span><br><span class="line">        <span class="keyword">else</span> Path[v]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S[v0]=<span class="literal">true</span>;</span><br><span class="line">    D[v0]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">       min=MaxInt;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;n;++w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!S[w]&amp;&amp;D[w]&lt;min)</span><br><span class="line">            &#123;v=w;min=D[w];&#125;</span><br><span class="line">            S[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;n;++w)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!S[w]&amp;&amp;D[v][w]&lt;D[w]))</span><br><span class="line">                &#123;</span><br><span class="line">                    D[w]=D[v]+G.arcs[v][w];</span><br><span class="line">                    Path[w]=v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>弗洛伊德算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(AMGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            D[i][j]=G.arcs[i][j];</span><br><span class="line">            <span class="keyword">if</span>(D[i][j]&lt;MaxInt &amp;&amp; i!=j) Path[i][j]=i;</span><br><span class="line">            <span class="keyword">else</span> Path[i][j]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.vexnum;++k)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnnum;++j)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)=</span><br><span class="line">                <span class="keyword">if</span>(D[i][k]+D[k][j]&lt;D[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    D[i][j]=D[i][k]+D[k][j];</span><br><span class="line">                    Path[i][j]=Path[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<p>​    </p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
